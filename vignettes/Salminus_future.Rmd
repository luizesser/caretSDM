---
title: "Salminus_future"
author: "Luíz Fernando Esser"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Salminus}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

`caretSDM` is a under development R package that uses the powerful `caret` package as the main engine to obtain Species Distribution Models. One of its main attributes is the strong geoprocessing underlying its functions. Here we show how to model species distributions using `caretSDM` through the function `sdm_area` with lines instead of polygons. This is implemented mostly thinking in HydroSHEDS database, which is particularly important for continental aquatic environments modeling. We also show how to avoid multicolinearity using a Variance Inflation Factor (VIF) routine. The aim of this modeling will be to obtain the current distribution of *Salminus brasiliensis*, a economically and ecologically key fish species from Paraná-Paraguay watershed.

First, we need to open our libraries.

```{r open libraries}
library(caretSDM)
library(stars) # Package used to manipulate GIS data
library(dplyr) # Package to improve data handling
```

### Pre-Processing

To obtain models, we will need climatic data and species records. To easily obtain these data, we have two functions: `WorldClim_data` function downloads climatic variables from WorldClim 2.1, a widely used open-source database; in the same way, `GBIF_data` function downloads species records from GBIF, also a widely used open-source database. You can read more about them by running in the console `?GBIF_data` and `?WorldClim_data`.

### Obtaining species records

A easy way to get species data using `caretSDM` is the function `GBIF_data`, which retrieves species records from GBIF. Understandably, there are other sources of species data available, as well as our own data that can be the result of field work. In this sense, one can import to R it's own data in multiple ways, but be sure that the table will have three columns: species, decimalLongitude and decimalLatitude. `GBIF_data` function retrieves the data ready to be included in caretSDM, thus if you have any doubt on how to format your own data, use `GBIF_data` function to retrieve an example table. Here we will use our own data from directory:

```{r occ_data}
# Import data
occ <- occurrences_sdm("input_data/Salminus.csv", crs = 4326)
occ
```

### Defining the study area

A important step on model building in Species Distribution Models, is the definition of accessible area (the M in BAM diagram). This area can be, in Geographical Information Systems terms, as an example, the delimitation of a habitat (polygon) or a river basin network (lines). Another broadly used approach is the use of buffers around presences. As we are working with a fish species, we will use a subset of hydroSHEDS database that is restricted to the Paraná-Paraguay watershed. In `caretSDM` there is a function that groups all the transformations regarding the study area to build and project the models. The `sdm_area` function is this function and is also responsible to check CRSs and create a grid to build models. This grid may seem unpurposed for terrestrial ecologists, but is a key element when modeling continental aquatic environments. `sdm_area` class will also keep the environmental/climatic data (*i.e.* "predictor variables", "covariates", "explanatory variables", "features" or "control variables"). With this class we will perform analysis using only the predictors (such as predictors transformations).

```{r sdm_area}
# Create a sdm_area object
sa <- sdm_area('input_data/parana_paraguay.gpkg', cell_size = 25000, crs = 6933, gdal = T)
sa
```

An alternative to visualize grid data is the use of mapview:

```{r mapview_grid}
mapview_grid(sa)
```

Now that we have a study area, we can assign predictors and scenarios variables to it.

### Obtaining climatic data

We will first download and import current data, which is used to build and project the models. `WorldClim_data` function has an argument to set the directory in which you want to save the files. If you don't set it, files will be saved in your working directory (run `getwd()` to find out your working dirrectory) in the folder "input_data/WorldClim_data_current/". We could run this script with a smaller resolution, but as the aim here is to show how the package works, we will use a resolution of 10 arc-minutes, which is very coarse, but quicker to download and run.

```{r WorldClim_data_current}
# Download current bioclimatic variables
WorldClim_data(period = "current", resolution = 10)

# Enter bioclimatic variables
pred <- read_stars(list.files("input_data/WorldClim_data_current/", full.names = T), along = "band", normalize_path = F)

# See what is inside pred
pred
```

Now we will add predictors to our study area:

```{r add_predictors}
# Add predictor variables into sdm_area
sa <- add_predictors(sa, pred)
sa
```

We can export the grid of the study area as a shape with the `write_grid` function. The function receives the `study_area` object and the file path in which the file should be written.

```{r export_grid}
write_grid(sa, "output_data/predictors_data.gpkg")
```

We also need to inform which scenarios we will be working with in projections. To start, we will add only the "current" scenario, which is the same data used as predictors.

```{r}
# Add predictors as scenarios:
sa <- add_scenarios(sa)
sa
```

Usually, we will need to subset variables that will inform our model. This can be due to statistical artifacts that are common in quarter bioclimatic variables, or a causation subset, aiming for those variables with causality effect on species distribution.

```{r select_preds}
# Select predictors
sa <- select(sa, c("LENGTH_KM", "DIST_DN_KM", "DIST_UP_KM", "CATCH_SKM", "UPLAND_SKM", "DIS_AV_CMS","X1.tif", "X2.tif", "X3.tif", "X4.tif", "X5.tif", "X6.tif", "X7.tif", "X12.tif", "X13.tif", "X14.tif", "X15.tif"))
sa <- set_predictor_names(sa, c("LENGTH_KM", "DIST_DN_KM", "DIST_UP_KM", "CATCH_SKM", "UPLAND_SKM", "DIS_AV_CMS","bio01","bio02", "bio03", "bio04", "bio05", "bio06", "bio07", "bio12", "bio13", "bio14", "bio15"))
sa
```

### Defining the occurrences set in the study area

As `caretSDM` has a strong GIS background, it is necessary to explicitly tell which CRS is your data in. This will assure that every GIS transformation is correct. This step also assigns occurrences into a study area, excluding records outside the study area or with NAs in predictors. `occurrences_sdm` function creates a occurrences class (*i.e.* "response variable", "target" or "label") that will be used in occurrences transformations and functions, as pseudoabsences generation.

```{r occurrences_sdm}
# Join occurrences to the study area
oc <- join_area(occ, sa)
oc
```

### The `input_sdm` class

In `caretSDM` we use multiple classes to perform our analysis. Every time we perform a new analysis, objects keep the information of what we did. Ideally, the workflow will have only one object throughout it. The `input_sdm` class is the key class in the workflow, where every function will orbitate. That class puts occurrences, predictors, scenarios, models and predictions together to perform analysis that are only possible when two or more of these classes are available. First, we create the object by informing the occurrences and sdm_area.

```{r input_sdm}
i <- input_sdm(oc, sa) ### exportar shape das ocorrências (com a grid)
i
```

Now we can visualize `oc` data using plot:

```{r plot_occurrences}
plot_occurrences(i)
```

Or, using mapview:

```{r mapview_occ}
mapview_occurrences(i)
```

We can also export the grid from study_area with occurrences data:

```{r}
write_occurrences(i, path = "results/occurrences.gpkg", grid = TRUE)
```

### Data cleaning routine

As the first step in our workflow with the `input_sdm` object, we will clean our occurrences data by applying a group of functions from the package `CoordinateCleaner`. In this function, we also provide a way to check for environmental duplicates, by including a predictors object. This function also checks for records in the sea if the species is terrestrial, but note that this can be switched off if the studied species is not terrestrial. The way `caretSDM` works, we can always overwrite the main `input_sdm` object to update it. The function will return a new object with all the previous information and the new information obtained from the `data_clean` function, note that at the end of the Data Cleaning information there is the Duplicated Cell method. This method is only possible when we have both the `occurrence` and `predictors` data.

```{r data_clean}
i <- data_clean(i, terrestrial = FALSE) ## colocar todos os ifs para cada teste.
i
```

Check the difference of occurrences data before applying the data cleaning routine:

```{r}
plot_occurrences(i)
```

```{r}
mapview_occurrences(i)
```

### Removing multicolinearity from predictors' data

In `vif_predictors`, we are able to perform two methods to select variables: selecting all area or using the presence records (which is debatable, but implemented). `vif_predictors` allows for a maximum threshold to be informed. The standard is 0.5.

```{r vif_predictors}
i <- vif_predictors(i, th = 0.5) ### método para presença+pseudoausência
### Fazer um vif_summary
i
```

### Obtaining pseudoabsence data

As we mentioned before, pseudoabsence data will be stored in the `occurrences` object (inside the `input_sdm`). To generate them, you can inform some parameters. The argument `variables_selected` will inform which variables you want to use to build your pseudoabsences/models. This can either be a vector of variables names or a previously performed selection method.

```{r pseudoabsence}
#### selecionar variáveis
i <- pseudoabsences(i, method = "bioclim", variables_selected = "vif") 
i
```

**TIP:** Note that the information regarding the `i` object has increased. Now it includes the information that we performed a Data Cleaning routine, explicitly informing what methods were used, the information regarding VIF routine and the pseudoabsences.

## Processing

### Modeling species relationship with variables

With the occurrences and predictors data put together, we can pass to the modeling. As the name suggests, `caretSDM` uses the `caret` package underlying its modeling procedure. For those who are not familiar, `caret` is the easiest way to perform Machine Learning analysis in R. It works by setting a modeling wrapper to pass multiple packages and can provide a lot of automation regarding algorithms fine-tuning, data spliting, pre-processing methods and predictions. These automated functions from `caret` can be altered using the `ctrl` argument in `train_sdm` function. See `?caret::trainControl` for all options available.

We show here how to use a repeated crossvalidation method, which is defined through `caret::trainControl`.

Note that, when you are using an algorithm for the first time, caret will ask you to install the relevant packages to properly run the algorithm.

```{r train_sdm, eval=TRUE}
ctrl_sdm <- caret::trainControl(method = "repeatedcv", 
                                number = 4, # Number of folds
                                repeats = 10, # Number of complete sets of folds to compute
                                classProbs = TRUE,
                                returnResamp = "all",
                                summaryFunction = summary_sdm,
                                savePredictions = "all")

i <- train_sdm(i, 
               algo = c("svmLinear2", "mda", "nnet", "kknn"), 
               crtl = ctrl_sdm, 
               variables_selected = "vif")
```

```{r}
i
```

### Incluir métricas de validação completas

With models built, we can see Partial Dependence Plots (a.k.a., response curves)...

```{r pdp_sdm}
pdp_sdm(i)
```

... and the variables importance.

```{r varImp_sdm}
varImp_sdm(i)
```

## Post-Processing

### Predicting species distribution in given scenarios

Now that we have our models, we can make predictions in new scenarios. The function `predict_sdm` incorporates also the prediction of ensembles (`ensembles=TRUE` is standard).

```{r predict_sdm}
i <- predict_sdm(i, th = 0.8)
i
```

To generate maps in `caretSDM` we can simply plot the `input_sdm` object using the function `plot_predictions`. This function has a series of arguments to plot specific maps within `i`. You can take a look at `?plot_predictions` to know more.

```{r plot_predictions}
plot_predictions(i, scenario = "current")
```

The same goes for mapview:

```{r}
mapview_predictions(i)
```

### writeResults (ensemble as .csv with centroids)\###

### Add future Data

```{r WorldClim_data_future}
# Download future scenarios
WorldClim_data(path="input_data/WorldClim_data_future/",period = "future", year = c('2050', '2090'), ssp = c('245','585'), resolution = 10)

# Import scenarios to R
scen <- read_stars(list.files("input_data/WorldClim_data_future/", full.names = T), normalize_path = F)

# See what is inside pred_data
scen
```

### 
